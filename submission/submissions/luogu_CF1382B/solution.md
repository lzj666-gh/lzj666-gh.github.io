# CF1382B 题解

- 分析

  我们可以发现对于**若干堆（第一堆数量大于 $1$ ）**，有这么一个贪心的取法：
  
  比如第一堆堆数量为 $n(n>1)$ 。**先手先取 $n-1$ 个。这样后手只能取 $1$ 个（无法不取）。**
  
  这样，先手就可以**先取第二堆**。
  
  后几堆的取法同上，直到先手可以先取最后一堆。
  
  **对于最后一堆，先手直接取完**。获胜。
  
  那如果**中间有一堆数量为 $1$ ，** 那么对于这一堆的前一堆，**直接全部取完**，后手只能取完这堆数量为 $1$ 的堆。**照样可以获得下一堆的先手**。
  
  以此类推。我们可以发现，影响最后结果的，**只有前缀 $1$ 的数量。**
  
  容易发现，如果**前缀 $1$ 数量为偶数个**，在轮流取完后，那么第一个非 $1$ 堆，是**先手**先取。即先手会胜利。
  
  如果是**奇数**个，那么第一个非 $1$ 堆，是**后手**先取。即后手会胜利。
  
  特殊的，如果这堆**只有 $1$ 。**那么**偶数**个胜利的为**后手**，**奇数**个胜利的为**先手**。
  
  

------------

  
- 代码

  ```
  #include<iostream>
  #include<cstdio>
  #include<cstring>
  using namespace std;
  const int Maxn=1e5+5;
  int T,n,a[Maxn];
  int main()
  {	
      scanf("%d",&T);
      while(T--)
      {	
          int cnt=0,i;
          scanf("%d",&n);
          for(i=1;i<=n;i++)
              scanf("%d",&a[i]);
          for(i=1;i<=n;i++)
              if(a[i]==1)cnt++;
              else break;
          if(i==n+1)
          {	
              if(cnt%2==0)printf("Second\n");
              else printf("First\n");
          }
          else{
              if(cnt%2==0)printf("First\n");
              else printf("Second\n");
          }
      }
      return 0;
  }
  ```
# P1434 题解

### 本题关键字：记忆化搜索。
**首先，这题为什么会想到记忆化？(知道的人直接跳过)**

在dfs每种情况是，可能这个点之前已经搜过了，没必要再去搜索了，因此不如存储记住，就没必要再去dfs了。


------------
本题的主要思路：

**1.先去想dfs怎么做：**

这题每个点出发有可能，所以我们每个点都要开始dfs，最后取他们的最大值。

dfs部分和类似的迷宫差不多,用两个数组表示4个方向：
```
dx[4]={0,0,1,-1};
dy[4]={1,-1,0,0};
```
改变方向直接xx=x+dx[i] , yy=y+dy[i]

接下来判断这个方向是否在地图范围内，即
```
if(xx>0&&xx<=R&&yy>0&&yy<=C)
```

当然还要判断这个点是否能滑到，也就是高度要前一个低：
```
if(a[xx][yy]<a[x][y])//a为高度
```
很明显，因为低的不可能滑向高的，所以我们不需要再开一个数组去记录这个点是否走过。

接下来，就要往四个方向搜索，取四个方向中距离最长的，然后+1，这就是这个点的结果了。

**2.记忆化搜索怎么写**

很显然，直接dfs会TLE。那么就需要记忆化来优化。

用s[i][j]表示从(i,j)点出发能走的最长距离。

每次搜索一次记忆一次即可。

下面给刚接触不怎么明白的人举例：(已经理解的人跳过)

由于样例不好讲我自己举例子：
```
3 3 
1 1 3
2 3 4
1 1 1
```
先去找(1,1)的最长距离，很明显为1

接着找(1,2)的最长距离，很明显为1

接着找(1,3)的最长距离，为2((1,3)->(1,2))

然后找(2,1)的最长距离，为2((2,1)->(1,1))

然后是(2,2)的最长距离，如果没有记忆化，那么搜索过程为：(2,2)->(2,1)->(1,1)

但是（2,1）之前已经搜过了，再去搜就是浪费时间，之前搜索已经知道(2,1)的值为2，那么搜索过程就是缩短为：(2,2)->(2,1),即为3


------------
下面附上我的代码：
```
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
int n,m,a[201][201],s[201][201],ans;
bool use[201][201];//这个就是所谓的不需要
int dfs(int x,int y){
    if(s[x][y])return s[x][y];//记忆化搜索
    s[x][y]=1;//题目中答案是有包含这个点的
    for(int i=0;i<4;i++)
    {  int xx=dx[i]+x;
       int yy=dy[i]+y;//四个方向
       if(xx>0&&yy>0&&xx<=n&&yy<=m&&a[x][y]>a[xx][yy]){
       	  dfs(xx,yy);
          s[x][y]=max(s[x][y],s[xx][yy]+1);
       }
    }
    return s[x][y];
}
int main()
{	
   scanf("%d%d",&n,&m);//同题目的R,C
   for(int i=1;i<=n;i++)
     for(int j=1;j<=m;j++)
       scanf("%d",&a[i][j]);
    for(int i=1;i<=n;i++)//找从每个出发的最长距离
      for(int j=1;j<=m;j++)
        ans=max(ans,dfs(i,j));//取最大值
    printf("%d",ans);
    return 0;
}
// by 路人七
```

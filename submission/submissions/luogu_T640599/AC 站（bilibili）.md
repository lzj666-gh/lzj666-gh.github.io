# AC 站（bilibili）

## 题目描述

AC 站具有一种神奇的特产，我们命名为视平吧，它是由阿噗主——另一种特殊生物创作的。阿噗主提交视平给另外的生物——申鹤来获取奖赏。

现在我们发现 AC 站有一串视平，它们都有各自的特征，而一个视平可以具有多个特征。

为了方便起见，我们定义一个特征为一个整数。

现在，我们发现有时阿噗主会集体创作，从而为一个区间的视平同时添加上同一个特征（因为是集体创作嘛），具体的说，向所有的视平后面添加同一个特征 $f(i)$，$i$ 为当前输入数字个数。特别的，$f(1)=1$。

而又有时，申鹤会对阿噗主的视平进行“咸六”，他需要知道一个区间的视平具有什么共同的特征以最好地进行“咸六”，所以，我们需要知道一个区间内的所有视平的最长公共子序列长度。

至于 $f$ 函数具体是什么呢？我也不知道，但是，我们可以从量子波动和虚数干扰中发现一些规律，通过逼近，我们得到 $f(n)=2\times f(n-1)+3\cdot (\sqrt[{(\frac{2\sqrt{2}}{9801}\sum_{k=0}^{\infty}\frac{(4k)!(1103+26390k)}{(k!)^{4}396^{4k}})}]{\lim_{t\to\infty}\left(1+\frac{1}{t}\right)^t})^{ni}$。

有人就会说了，这个函数太长了，看不懂，我要把你评为“最锅的题”！

这可真是太糟糕了，所以良心的出题人向你们提供了一些提示（不保证有用）。

| 一些提示 | ${(\frac{2\sqrt{2}}{9801}\sum_{k=0}^{\infty}\frac{(4k)!(1103+26390k)}{(k!)^{4}396^{4k}})}$ | $\lim_{t\to\infty}\left(1+\frac{1}{t}\right)^t$ |
| :----------: | :----------: | :----------: |
|前1项的近似值:|0.31830987844047012321768445317891990218597042720963|2.00000000000000000000000000000000000000000000000000|
|前2项的近似值:|0.31830988618379060673919643382082822511793407438051|2.25000000000000000000000000000000000000000000000000|
|前5项的近似值:|0.31830988618379067153776752674502872406886919638714|2.48831999999999942119188744982238858938217163085938|
|前10项的近似值:|0.31830988618379067153776752674502872406891929148091|2.59374246010000231166259254678152501583099365234375|
|前50项的近似值:|0.31830988618379067153776752674502872406891929148091|2.69158802907360783507328960695303976535797119140625|
|前100项的近似值| 0.31830988618379067153776752674502872406891929148091|2.70481382942152848158912092912942171096801757812500|

还有，一些神秘的公式出现了：$e^{i\pi}=-1;F(\omega)=\int_{-\infty}^{\infty} f(t) e^{-j \omega t} d t$。

最后，我们发现这道题的输入输出很有可能导致大量时间问题，所以我们采用特殊的输入输出方式。

## 输入格式

我们将输入测试点编号和一个数字，你需要调用数据生成器中的 `data_init(int, int)` 以初始化，并通过调用输入数据生成器的方式来给出输入。

首先，你应当调用四次生成器（`next_int()` 返回结果），以获得 $N,Q,online,mode$，$N,Q$ 表示视平个数以及操作个数。

接下来 $Q$ 次操作，每次操作调用三次生成器获得，三个正整数，具体含义如下。

| 输入格式 |                             意思                             |
| :------: | :----------------------------------------------------------: |
| `1 l r`  | 将 $[l,r]$ 的序列后面加上元素 $f(i)$，$i$ 为当前已输入数字个数 |
| `2 l r`  |    询问所有编号在 $[l,r]$ 内的序列的最长公共子序列长度     |

现在，我们记 `last_ans` 为上一次查询的答案，初始时 `last_ans` 为 $3279$。若 `online` 为 $1$，则除了第一个操作符，都要异或上上一次查询的答案 `last_ans`。

在异或过后，我们令 $l'\leftarrow l\bmod N+1;r'\leftarrow r\bmod N+1$，再 $l\leftarrow\min(l',r');r\leftarrow\max(l',r')$。

若 `mode` 为 $1$，则额外调用一次获取 $K$。

## 输出格式

我们通过特殊的方式输出答案。

我们将所有查询的结果作为一个大小为 $L$ 的数组 $A_0\cdots A_{L-1}$ 的元素。

- 若 `mode` 为 $1$，我们将给出一个常数 $K$，对于所有 $k\isin[1,K]$，令 $l=min(k,L-k-1),r=max(k,L-k-1)$ 构造一个尽可能低次的多项整式函数经过 $i\isin [l,r]$ 的 $(k\times i,A_i)$，求当 $x=(r+1)\times k$ 时的函数值乘上区间长度之和是多少。
- 若 `mode` 为 $0$，我们将求出这个数组的所有子区间的异或值之和。

为了防止答案过大，我们将答案取余 $9982443353$。

一行，一个整数 $ans$，表示答案。

## 提示

### 样例解释

输入解码后如下所示：

```text
10 10 0 0
2 1 10
1 1 10
2 1 10
1 1 10
1 1 10
1 1 10
1 1 10
2 1 10
2 1 10
2 1 10
```

答案分别为

```text
0
1
5
5
5
```

2s，512MiB

对于所有数据，$N\le 10^9,Q\le 10^5,K\le L$。保证查询操作不超过 $10000$ 次。

| 测试点编号 | $N\le$ | $Q\le$ | `online` | `mode` | 特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1\sim4$ | $10^2$ | $10^2$ | 1 | 0 |  |
| $5\sim6$ | $10^4$ | $10^3$ | 1 | 0 |  |
| $7\sim8$ | $10^4$ | $10^3$ | 1 | 1 |  |
| $9\sim12$ | $10^7$ | $10^5$ | 0 | 0 |  |
| $13\sim16$ | $10^7$ | $10^5$ | 0 | 1 |  |
| $17\sim18$ | $10^9$ | $10^5$ | 1 | 0 |  |
| $19\sim20$ | $10^9$ | $10^5$ | 1 | 1 |  |

数据生成器：

```cpp
namespace dg {
	struct TP { long long N; int Q, on, md, ql; };
	const TP tps[21] = {
		{10, 10, 0, 0, 0}, { 100, 100, 1, 0, 0 }, {100, 100, 1, 0, 0}, {100, 100, 1, 0, 0}, {100, 100, 1, 0, 0},
		{10000, 1000, 1, 0, 0}, {10000, 1000, 1, 0, 0}, {10000, 1000, 1, 1, 0}, {10000, 1000, 1, 1, 0},
		{10000000, 100000, 0, 0, 10000}, {10000000, 100000, 0, 0, 10000}, {10000000, 100000, 0, 0, 10000}, {10000000, 100000, 0, 0, 10000},
		{10000000, 100000, 0, 1, 10000}, {10000000, 100000, 0, 1, 10000}, {10000000, 100000, 0, 1, 10000}, {10000000, 100000, 0, 1, 10000},
		{1000000000, 100000, 1, 0, 10000}, {1000000000, 100000, 1, 0, 10000}, {1000000000, 100000, 1, 1, 10000}, {1000000000, 100000, 1, 1, 10000}
	};
	uint64_t s0, s1;
	int tid, st, ct, opc, qc, cop;
	long long Nv, Qv, onv, mdv, cl, cr, last_l;
	void data_init(int id, int sd) {
		s0 = 0x8a5cd789635d2dffULL ^ (sd + 1);
		s1 = 0x121fd2155c472f96ULL ^ (sd + 1);
		if (!s0 && !s1) s0 = 1;
		tid = id; st = ct = opc = qc = 0;
		Nv = tps[tid].N;
		Qv = tps[tid].Q;
		onv = tps[tid].on;
		mdv = tps[tid].md;
	}
	uint64_t xrand() {
		uint64_t x = s0, y = s1;
		s0 = y; x ^= x << 23;
		s1 = x ^ y ^ (x >> 17) ^ (y >> 26);
		return s1 + y;
	}
	long long nxt(long long a, long long b) {
		if (a > b) return a;
		if (a == b) return a;
		uint64_t r = xrand();
		return a + r % (b - a + 1);
	}
	void gen_interval(long long& l, long long& r) {
		if (xrand() % 100 < 70) {
			l = 1;
			r = Nv;
			return;
		}
		long long min_len = min(1000000LL, Nv / 10);
		if (min_len < 10000) min_len = 10000;
		if (min_len > Nv) min_len = Nv;
		long long len = nxt(min_len, Nv);
		l = nxt(1, Nv - len + 1);
		r = l + len - 1;
	}
	long long next_int() {
		if (st == 0) {
			if (ct == 0) { ct++; return Nv; }
			if (ct == 1) { ct++; return Qv; }
			if (ct == 2) { ct++; return onv; }
			st = 1; ct = 0; return mdv;
		}
		if (st == 1) {
			if (opc >= Qv) {
				st = 2;
				return mdv ? qc ? nxt(1, qc) : 0 : 0;
			}
			if (ct == 0) {
				if (tps[tid].ql > 0 && qc >= tps[tid].ql) cop = 1;
				else if (opc > Qv * 0.8) cop = (xrand() % 100 < 90) ? 2 : 1;
				else if (opc > Qv * 0.6) cop = (xrand() % 100 < 60) ? 2 : 1;
				else cop = (xrand() % 100 < 20) ? 2 : 1;
				ct = 1;
				return cop;
			}
			if (ct == 1) {
				gen_interval(cl, cr);
				last_l = cl;
				last_l = max(1LL, min(Nv, last_l));
				ct = 2;
				return last_l;
			}
			long long r_val = cr;
			r_val = max(1LL, min(Nv, r_val));
			r_val = max(last_l, r_val);
			if (cop == 2) qc++;
			ct = 0; opc++;
			return r_val;
		}
		return 0;
	}
}
```

## 时空限制

时间限制: 1000 ms
内存限制: 512 MB

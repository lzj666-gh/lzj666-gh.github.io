//  OJ: 洛谷
//  提交ID: 226886367
//  题目ID: T640599
#include<bits/stdc++.h>
#define MAXKN 20
using namespace std;
namespace dg {
	struct TP { long long N; int Q, on, md, ql; };
	const TP tps[20] = {
		{100, 100, 1, 0, 0}, {100, 100, 1, 0, 0}, {100, 100, 1, 0, 0}, {100, 100, 1, 0, 0},
		{10000, 1000, 1, 0, 0}, {10000, 1000, 1, 0, 0}, {10000, 1000, 1, 1, 0}, {10000, 1000, 1, 1, 0},
		{10000000, 100000, 0, 0, 0}, {10000000, 100000, 0, 0, 0}, {10000000, 100000, 0, 0, 0}, {10000000, 100000, 0, 0, 0},
		{10000000, 100000, 0, 1, 10000}, {10000000, 100000, 0, 1, 10000}, {10000000, 100000, 0, 1, 10000}, {10000000, 100000, 0, 1, 10000},
		{1000000000, 100000, 1, 0, 0}, {1000000000, 100000, 1, 0, 0}, {1000000000, 100000, 1, 1, 10000}, {1000000000, 100000, 1, 1, 10000}
	};
	uint64_t s0, s1;
	int tid, st, ct, opc, qc;
	long long Nv, Qv, onv, mdv, cl;
	void data_init(int id, int sd) {
		s0 = 0x8a5cd789635d2dffULL ^ (sd + 1);
		s1 = 0x121fd2155c472f96ULL ^ (sd + 1);
		if (!s0 && !s1) s0 = 1;
		tid = id - 1;
		st = ct = opc = qc = 0;
	}
	uint64_t xrand() {
		uint64_t x = s0;
		uint64_t y = s1;
		s0 = y;
		x ^= x << 23;
		s1 = x ^ y ^ (x >> 17) ^ (y >> 26);
		return s1 + y;
	}
	long long nxt(long long a, long long b) {
		if (a > b) return a;
		uint64_t r = xrand(), rg = b - a + 1, lm = (UINT64_MAX / rg) * rg;
		while (r >= lm) r = xrand();
		return a + r % rg;
	}
	long long next_int() {
		if (st == 0) {
			if (ct == 0) { Nv = nxt(1, tps[tid].N); ct++; return Nv; }
			if (ct == 1) { Qv = nxt(1, tps[tid].Q); ct++; return Qv; }
			if (ct == 2) { onv = tps[tid].on; ct++; return onv; }
			mdv = tps[tid].md; st = 1; ct = 0; return mdv;
		}
		if (st == 1) {
			if (opc >= Qv) {
				st = 2;
				return mdv ? qc ? nxt(1, qc) : 0 : 0;
			}
			if (ct == 0) {
				if (tps[tid].ql && qc >= tps[tid].ql) ct = 1;
				else ct = nxt(1, 100) <= 20 ? 2 : 1;
				return ct;
			}
			if (ct == 1) {
				cl = nxt(1, Nv); ct = 3;
				return cl;
			}
			long long rw = nxt(cl, Nv);
			if (ct == 2) qc++;
			ct = 0; opc++;
			return rw;
		}
		return 0;
	}
}
using namespace dg;
template<int K = 2>
class Point {
private:
	int x[K];
public:
	Point() { memset(x, 0, sizeof(x)); }
	Point(initializer_list<int> pos) {
		auto it = pos.begin();
		for (int i = 0; i < K; i++, it++) x[i] = *it;
	}
	Point(const Point& other) {
		for (int i = 0; i < K; i++) x[i] = other.x[i];
	}
	Point(const vector<int>& other) {
		for (int i = 0; i < K; i++) x[i] = other[i];
	}
	int& operator[](int index) {
		return x[index];
	}
	const int& operator[](int index) const {
		return x[index];
	}
	void operator=(const Point& other) {
		for (int i = 0; i < K; i++) x[i] = other.x[i];
	}
	bool operator==(const Point& other) const {
		for (int i = 0; i < K; i++)
			if (x[i] != other.x[i])
				return false;
		return true;
	}
	bool operator!=(const Point& other) const {
		for (int i = 0; i < K; i++)
			if (x[i] != other.x[i])
				return true;
		return false;
	}
	bool operator<(const Point& other) const {
		for (int i = 0; i < K; i++)
			if (x[i] != other.x[i])
				return x[i] < other.x[i];
		return false;
	}
	bool operator>(const Point& other) const {
		for (int i = 0; i < K; i++)
			if (x[i] != other.x[i])
				return x[i] > other.x[i];
		return false;
	}
	bool operator()(const Point& L, const Point& R)const {
		for (int i = 0; i < K; i++)
			if (!(L[i] <= x[i] && x[i] <= R[i]))
				return false;
		return true;
	}
	friend ostream& operator<<(ostream& os, const Point<K>& x) {
		os << "(";
		for (int i = 0; i < K; i++) os << x[i] << (i == K - 1 ? "" : ", ");
		os << ")";
		return os;
	}
};
//(Lson,Rson) isin (lson,rson)
template<int K = 2>
bool inside(const Point<K>& Lson, const Point<K>& Rson, const Point<K>& lson, const Point<K>& rson) {
	for (int i = 0; i < K; i++)
		if (!(lson[i] <= Lson[i] && Rson[i] <= rson[i]))
			return false;
	return true;
}
//(Lson,Rson) intersect (lson,rson)
template<int K = 2>
bool intersect(const Point<K>& Lson, const Point<K>& Rson, const Point<K>& lson, const Point<K>& rson) {
	for (int i = 0; i < K; i++)
		if (Rson[i] < lson[i] || rson[i] < Lson[i])
			return false;
	return true;
}
template<int K = 2>
struct KDTree {
	struct Node {
		int cnt;
		long long sum;
		int lson, rson;
		Point<K> pos, lpos, rpos;
		Node() : cnt(0), sum(0), lson(0), rson(0) {}
	}tree[200000 + 5];
	int pushup(int p) {
		tree[p].sum = tree[tree[p].lson].sum + tree[tree[p].rson].sum + tree[p].cnt;
		tree[p].lpos = tree[p].pos, tree[p].rpos = tree[p].pos;
		for (int i = 0; i < K; i++) {
			if (tree[p].lson) {
				tree[p].lpos[i] = min(tree[p].lpos[i], tree[tree[p].lson].lpos[i]);
				tree[p].rpos[i] = max(tree[p].rpos[i], tree[tree[p].lson].rpos[i]);
			}
			if (tree[p].rson) {
				tree[p].lpos[i] = min(tree[p].lpos[i], tree[tree[p].rson].lpos[i]);
				tree[p].rpos[i] = max(tree[p].rpos[i], tree[tree[p].rson].rpos[i]);
			}
		}
		return p;
	}
	struct Stack_ {
		struct Node {
			int val;
			Node* nxt;
			Node(int val, Node* nxt) : val(val), nxt(nxt) {}
		};
		Node* head;
		void push(int val) {
			head = new Node(val, head);
		}
		int top() {
			static int idx;
			if (head == nullptr) return ++idx;
			return head->val;
		}
		void pop() {
			if (head == nullptr) return;
			Node* tmp = head;
			head = head->nxt;
			delete tmp;
		}
		void clear() {
			while (head != nullptr) {
				Node* tmp = head;
				head = head->nxt;
				delete tmp;
			}
		}
	};
	struct Stack {
		vector<pair<Point<K>, int>> st;
		void push(pair<Point<K>, int> val) {
			st.push_back(val);
		}
		pair<Point<K>, int> top() {
			return st.back();
		}
		void pop() {
			st.pop_back();
		}
		void clear() {
			st.clear();
		}
		int size() {
			return st.size();
		}
		pair<Point<K>, int> operator[](int index) {
			return st[index];
		}
		void unique() {
			sort(st.begin(), st.end());
			vector<pair<Point<K>, int>> new_st;
			for (size_t i = 0; i < st.size(); ++i) {
				if (!new_st.empty() && new_st.back().first == st[i].first) {
					new_st.back().second += st[i].second;
				}
				else {
					new_st.push_back(st[i]);
				}
			}
			st.swap(new_st);
		}
	};
	Stack_ st;
	Stack Merge;
	void dfs(int x) {
		if (!x) return;
		st.push(x);
		Merge.push(make_pair(tree[x].pos, tree[x].cnt));
		dfs(tree[x].lson);
		dfs(tree[x].rson);
	}
	int build(int l, int r, int k) {
		if (l > r) return 0;
		int x = st.top(); st.pop();
		memset(tree + x, 0, sizeof(Node));
		if (l == r) {
			tree[x].pos = Merge.st[l].first;
			tree[x].cnt = Merge.st[l].second;
			tree[x].lson = tree[x].rson = 0;
			return pushup(x);
		}
		int mid = l + r >> 1;
		nth_element(Merge.st.begin() + l, Merge.st.begin() + mid, Merge.st.begin() + r + 1,
			[&](const pair<Point<K>, int>& a, const pair<Point<K>, int>& b) {
				if (a.first[k] != b.first[k])
					return a.first[k] < b.first[k];
				return a.first < b.first;
			});
		tree[x].pos = Merge.st[mid].first;
		tree[x].cnt = Merge.st[mid].second;
		tree[x].lson = build(l, mid - 1, (k + 1) % K);
		tree[x].rson = build(mid + 1, r, (k + 1) % K);
		return pushup(x);
	}
	int merge(int ra, int rb) {
		st.clear();
		dfs(ra); dfs(rb);
		Merge.unique();
		return build(0, Merge.st.size() - 1, 0);
	}
	int root[MAXKN];
	void insert(Point<K> pos, int val) {
		Merge.push(make_pair(pos, val));
		int r = build(0, 0, 0);
		Merge.clear();
		int i = 0;
		for (; i < MAXKN; ++i) {
			if (root[i] == 0) break;
			r = merge(root[i], r);
			root[i] = 0;
			Merge.clear();
		}
		root[i] = r;
	}
	long long query(int x, const Point<K>& Lson, const Point<K>& Rson) {
		if (x == 0) return 0;
		if (inside(tree[x].lpos, tree[x].rpos, Lson, Rson)) return tree[x].sum;
		long long ans = 0;
		if (intersect(tree[x].lpos, tree[x].rpos, Lson, Rson)) {
			if (inside(tree[x].pos, tree[x].pos, Lson, Rson))
				ans += tree[x].cnt;
			ans += query(tree[x].lson, Lson, Rson);
			ans += query(tree[x].rson, Lson, Rson);
		}
		return ans;
	}
	long long query(const Point<K>& Lson, const Point<K>& Rson) {
		long long ans = 0;
		for (int i = 0; i < MAXKN; i++)
			ans += query(root[i], Lson, Rson);
		return ans;
	}
	KDTree() {
		memset(root, 0, sizeof(root));
		memset(tree, 0, sizeof(tree));
		st.clear();
	}
};
KDTree<2> tree;
int n, m, op, x, y;
long long** a;
const long long mod = 9982443353;
long long solve(int x, int y) {
	long long ans = 0;
	for (int i = 0; i <= x; ++i) {
		ans = (a[x - i][y + i] - ans) % mod;
		if (ans < 0) ans += mod;
	}
	return ans;
}
int special, online;
int main() {
	int testid, seed;
	cin >> testid >> seed;
	data_init(testid, seed);
	vector<int> ans;
	int last_ans = 0xccf;
	n = next_int(); m = next_int(); online = next_int(); special = next_int();
	for (int i = 1; i <= m; i++) {
		op = next_int(); x = next_int(); y = next_int();
		if (online) x ^= last_ans, y ^= last_ans;
		x = (x - 1) % n + 1; y = (y - 1) % n + 1;
		if (x > y) swap(x, y);
		if (op == 1)
			tree.insert({ x,y }, 1);
		else {
			int tmp = tree.query({ 1,y }, { x,n });
			ans.push_back(tmp);
			last_ans = tmp;
		}
	}
	int L = ans.size();
	if (!special) {
		int sum = 0;
		for (int i = 1; i < L; ++i) ans[i] ^= ans[i - 1];
		for (int i = 0; i < L; ++i)
			for (int j = i; j < L; ++j)
				sum = (sum + (ans[j] ^ (i == 0 ? 0 : ans[i - 1]))) % mod;
		cout << sum << endl;
		return 0;
	}
	int K = next_int();
	a = new long long* [L + 1];
	for (int i = 0, j = L; i < L; i++, j--)
		a[i] = new long long[j];
	for (int i = 0; i < L; ++i)
		a[0][i] = ans[i] % mod;
	for (int i = 1; i < L; i++) {
		int k = L - i;
		for (int j = 0; j < k; j++) {
			a[i][j] = (a[i - 1][j] - a[i - 1][j + 1]) % mod;
			if (a[i][j] < 0) a[i][j] += mod;
		}
	}
	long long anss = 0;
	for (int k = 1; k <= K; k++) {
		int l = min(k - 1, L - k);
		int r = max(k - 1, L - k);
		int x = r - l;
		long long val = solve(x, l);
		anss = (anss + val * (x + 1)) % mod;
	}
	anss %= mod;
	if (anss < 0) anss += mod;
	cout << anss << endl;
	return 0;
}
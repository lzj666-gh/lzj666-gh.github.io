//  OJ: 洛谷
//  提交ID: 226877852
//  题目ID: T640599
#include<bits/stdc++.h>
#include<random>
#define MAXKN 20
using namespace std;
namespace data_generator {
    struct TestPoint {
        long long N_max;
        int Q_max;
        int online;
        int mode;
        int query_limit;
    };

    const TestPoint testPoints[20] = {
        {100, 100, 1, 0, 0},        // 1
        {100, 100, 1, 0, 0},        // 2
        {100, 100, 1, 0, 0},        // 3
        {100, 100, 1, 0, 0},        // 4
        {10000, 1000, 1, 0, 0},     // 5
        {10000, 1000, 1, 0, 0},     // 6
        {10000, 1000, 1, 1, 0},     // 7
        {10000, 1000, 1, 1, 0},     // 8
        {10000000, 100000, 0, 0, 0},// 9
        {10000000, 100000, 0, 0, 0},// 10
        {10000000, 100000, 0, 0, 0},// 11
        {10000000, 100000, 0, 0, 0},// 12
        {10000000, 100000, 0, 1, 10000}, //13
        {10000000, 100000, 0, 1, 10000}, //14
        {10000000, 100000, 0, 1, 10000}, //15
        {10000000, 100000, 0, 1, 10000}, //16
        {1000000000, 100000, 1, 0, 0}, //17
        {1000000000, 100000, 1, 0, 0}, //18
        {1000000000, 100000, 1, 1, 10000}, //19
        {1000000000, 100000, 1, 1, 10000}  //20
    };

    static std::mt19937 rng;
    static int test_id_val;
    static const TestPoint* tp;
    static int stage;
    static int count_stage;
    static long long N_val, Q_val;
    static int online_val, mode_val;
    static int op_count;
    static long long last_ans;
    static int cnt_query;
    static int current_op;
    static long long current_l_raw;

    void data_init(int test_id, int num) {
        rng = std::mt19937(num);
        test_id_val = test_id;
        tp = &testPoints[test_id - 1];
        stage = 0;
        count_stage = 0;
        op_count = 0;
        last_ans = 0;
        cnt_query = 0;
        current_op = 0;
        current_l_raw = 0;
    }

    int next_int() {
        if (stage == 0) {
            if (count_stage == 0) {
                std::uniform_int_distribution<long long> dist_N(1, tp->N_max);
                N_val = dist_N(rng);
                count_stage++;
                return N_val;
            }
            else if (count_stage == 1) {
                std::uniform_int_distribution<long long> dist_Q(1, tp->Q_max);
                Q_val = dist_Q(rng);
                count_stage++;
                return Q_val;
            }
            else if (count_stage == 2) {
                online_val = tp->online;
                count_stage++;
                return online_val;
            }
            else if (count_stage == 3) {
                mode_val = tp->mode;
                count_stage++;
                stage = 1;
                count_stage = 0;
                return mode_val;
            }
        }
        else if (stage == 1) {
            if (op_count >= Q_val) {
                stage = 2;
                if (mode_val == 1) {
                    int K_val;
                    if (cnt_query == 0) {
                        K_val = 0;
                    }
                    else {
                        std::uniform_int_distribution<int> dist_K(1, cnt_query);
                        K_val = dist_K(rng);
                    }
                    stage = 3;
                    return K_val;
                }
                else {
                    return 0;
                }
            }

            if (count_stage == 0) {
                if (tp->query_limit > 0 && cnt_query >= tp->query_limit) {
                    current_op = 1;
                }
                else {
                    if (std::uniform_real_distribution<double>(0.0, 1.0)(rng) < 0.2) {
                        current_op = 2;
                    }
                    else {
                        current_op = 1;
                    }
                }
                count_stage = 1;
                return current_op;
            }
            else if (count_stage == 1) {
                std::uniform_int_distribution<long long> dist_l(1, N_val);
                current_l_raw = dist_l(rng);
                long long l;
                if (op_count >= 1 && online_val) {
                    l = current_l_raw ^ last_ans;
                }
                else {
                    l = current_l_raw;
                }
                count_stage = 2;
                return l;
            }
            else if (count_stage == 2) {
                std::uniform_int_distribution<long long> dist_r(current_l_raw, N_val);
                long long r_raw = dist_r(rng);
                long long r;
                if (op_count >= 1 && online_val) {
                    r = r_raw ^ last_ans;
                }
                else {
                    r = r_raw;
                }
                if (current_op == 2) {
                    std::uniform_int_distribution<long long> dist_ans(0, 1000000);
                    last_ans = dist_ans(rng);
                    cnt_query++;
                }
                count_stage = 0;
                op_count++;
                return r;
            }
        }
        else if (stage == 2) {
            if (mode_val == 1) {
                int K_val;
                if (cnt_query == 0) {
                    K_val = 0;
                }
                else {
                    std::uniform_int_distribution<int> dist_K(1, cnt_query);
                    K_val = dist_K(rng);
                }
                stage = 3;
                return K_val;
            }
            else {
                stage = 3;
                return 0;
            }
        }
        return 0;
    }
}
using namespace data_generator;
template<int K = 2>
class Point {
private:
    int x[K];
public:
    Point() { memset(x, 0, sizeof(x)); }
    Point(initializer_list<int> pos) {
        auto it = pos.begin();
        for (int i = 0; i < K; i++, it++) x[i] = *it;
    }
    Point(const Point& other) {
        for (int i = 0; i < K; i++) x[i] = other.x[i];
    }
    Point(const vector<int>& other) {
        for (int i = 0; i < K; i++) x[i] = other[i];
    }
    int& operator[](int index) {
        return x[index];
    }
    const int& operator[](int index) const {
        return x[index];
    }
    void operator=(const Point& other) {
        for (int i = 0; i < K; i++) x[i] = other.x[i];
    }
    bool operator==(const Point& other) const {
        for (int i = 0; i < K; i++)
            if (x[i] != other.x[i])
                return false;
        return true;
    }
    bool operator!=(const Point& other) const {
        for (int i = 0; i < K; i++)
            if (x[i] != other.x[i])
                return true;
        return false;
    }
    bool operator<(const Point& other) const {
        for (int i = 0; i < K; i++)
            if (x[i] != other.x[i])
                return x[i] < other.x[i];
        return false;
    }
    bool operator>(const Point& other) const {
        for (int i = 0; i < K; i++)
            if (x[i] != other.x[i])
                return x[i] > other.x[i];
        return false;
    }
    bool operator()(const Point& L, const Point& R)const {
        for (int i = 0; i < K; i++)
            if (!(L[i] <= x[i] && x[i] <= R[i]))
                return false;
        return true;
    }
    friend ostream& operator<<(ostream& os, const Point<K>& x) {
        os << "(";
        for (int i = 0; i < K; i++) os << x[i] << (i == K - 1 ? "" : ", ");
        os << ")";
        return os;
    }
};
//(Lson,Rson) isin (lson,rson)
template<int K = 2>
bool inside(const Point<K>& Lson, const Point<K>& Rson, const Point<K>& lson, const Point<K>& rson) {
    for (int i = 0; i < K; i++)
        if (!(lson[i] <= Lson[i] && Rson[i] <= rson[i]))
            return false;
    return true;
}
//(Lson,Rson) intersect (lson,rson)
template<int K = 2>
bool intersect(const Point<K>& Lson, const Point<K>& Rson, const Point<K>& lson, const Point<K>& rson) {
    for (int i = 0; i < K; i++)
        if (Rson[i] < lson[i] || rson[i] < Lson[i])
            return false;
    return true;
}
template<int K = 2>
struct KDTree {
    struct Node {
        int cnt;
        long long sum;
        int lson, rson;
        Point<K> pos, lpos, rpos;
        Node() : cnt(0), sum(0), lson(0), rson(0) {}
    }tree[200000 + 5];
    int pushup(int p) {
        tree[p].sum = tree[tree[p].lson].sum + tree[tree[p].rson].sum + tree[p].cnt;
        tree[p].lpos = tree[p].pos, tree[p].rpos = tree[p].pos;
        for (int i = 0; i < K; i++) {
            if (tree[p].lson) {
                tree[p].lpos[i] = min(tree[p].lpos[i], tree[tree[p].lson].lpos[i]);
                tree[p].rpos[i] = max(tree[p].rpos[i], tree[tree[p].lson].rpos[i]);
            }
            if (tree[p].rson) {
                tree[p].lpos[i] = min(tree[p].lpos[i], tree[tree[p].rson].lpos[i]);
                tree[p].rpos[i] = max(tree[p].rpos[i], tree[tree[p].rson].rpos[i]);
            }
        }
        return p;
    }
    struct Stack_ {
        struct Node {
            int val;
            Node* nxt;
            Node(int val, Node* nxt) : val(val), nxt(nxt) {}
        };
        Node* head;
        void push(int val) {
            head = new Node(val, head);
        }
        int top() {
            static int idx;
            if (head == nullptr) return ++idx;
            return head->val;
        }
        void pop() {
            if (head == nullptr) return;
            Node* tmp = head;
            head = head->nxt;
            delete tmp;
        }
        void clear() {
            while (head != nullptr) {
                Node* tmp = head;
                head = head->nxt;
                delete tmp;
            }
        }
    };
    struct Stack {
        vector<pair<Point<K>, int>> st;
        void push(pair<Point<K>, int> val) {
            st.push_back(val);
        }
        pair<Point<K>, int> top() {
            return st.back();
        }
        void pop() {
            st.pop_back();
        }
        void clear() {
            st.clear();
        }
        int size() {
            return st.size();
        }
        pair<Point<K>, int> operator[](int index) {
            return st[index];
        }
        void unique() {
            sort(st.begin(), st.end());
            vector<pair<Point<K>, int>> new_st;
            for (size_t i = 0; i < st.size(); ++i) {
                if (!new_st.empty() && new_st.back().first == st[i].first) {
                    new_st.back().second += st[i].second;
                }
                else {
                    new_st.push_back(st[i]);
                }
            }
            st.swap(new_st);
        }
    };
    Stack_ st;
    Stack Merge;
    void dfs(int x) {
        if (!x) return;
        st.push(x);
        Merge.push(make_pair(tree[x].pos, tree[x].cnt));
        dfs(tree[x].lson);
        dfs(tree[x].rson);
    }
    int build(int l, int r, int k) {
        if (l > r) return 0;
        int x = st.top(); st.pop();
        memset(tree + x, 0, sizeof(Node));
        if (l == r) {
            tree[x].pos = Merge.st[l].first;
            tree[x].cnt = Merge.st[l].second;
            tree[x].lson = tree[x].rson = 0;
            return pushup(x);
        }
        int mid = l + r >> 1;
        nth_element(Merge.st.begin() + l, Merge.st.begin() + mid, Merge.st.begin() + r + 1,
            [&](const pair<Point<K>, int>& a, const pair<Point<K>, int>& b) {
                if (a.first[k] != b.first[k])
                    return a.first[k] < b.first[k];
                return a.first < b.first;
            });
        tree[x].pos = Merge.st[mid].first;
        tree[x].cnt = Merge.st[mid].second;
        tree[x].lson = build(l, mid - 1, (k + 1) % K);
        tree[x].rson = build(mid + 1, r, (k + 1) % K);
        return pushup(x);
    }
    int merge(int ra, int rb) {
        st.clear();
        dfs(ra); dfs(rb);
        Merge.unique();
        return build(0, Merge.st.size() - 1, 0);
    }
    int root[MAXKN];
    void insert(Point<K> pos, int val) {
        Merge.push(make_pair(pos, val));
        int r = build(0, 0, 0);
        Merge.clear();
        int i = 0;
        for (; i < MAXKN; ++i) {
            if (root[i] == 0) break;
            r = merge(root[i], r);
            root[i] = 0;
            Merge.clear();
        }
        root[i] = r;
    }
    long long query(int x, const Point<K>& Lson, const Point<K>& Rson) {
        if (x == 0) return 0;
        if (inside(tree[x].lpos, tree[x].rpos, Lson, Rson)) return tree[x].sum;
        long long ans = 0;
        if (intersect(tree[x].lpos, tree[x].rpos, Lson, Rson)) {
            if (inside(tree[x].pos, tree[x].pos, Lson, Rson))
                ans += tree[x].cnt;
            ans += query(tree[x].lson, Lson, Rson);
            ans += query(tree[x].rson, Lson, Rson);
        }
        return ans;
    }
    long long query(const Point<K>& Lson, const Point<K>& Rson) {
        long long ans = 0;
        for (int i = 0; i < MAXKN; i++)
            ans += query(root[i], Lson, Rson);
        return ans;
    }
    KDTree() {
        memset(root, 0, sizeof(root));
        memset(tree, 0, sizeof(tree));
        st.clear();
    }
};
KDTree<2> tree;
int n, m, op, x, y;
long long** a;
const long long mod = 9982443353;
long long solve(int x, int y) {
    long long ans = 0;
    for (int i = 0; i <= x; ++i) {
        ans = (a[x - i][y + i] - ans) % mod;
        if (ans < 0) ans += mod;
    }
    return ans;
}
int special, online;
int main() {
    int testid, seed;
    cin >> testid >> seed;
    data_init(testid, seed);
    vector<int> ans;
    int last_ans = 0xccf;
    n = next_int(); m = next_int(); online = next_int(); special = next_int();
    for (int i = 1; i <= m; i++) {
        op = next_int(); x = next_int(); y = next_int();
        if (online) x ^= last_ans, y ^= last_ans;
        x = (x - 1) % n + 1; y = (y - 1) % n + 1;
        if (x > y) swap(x, y);
        if (op == 1)
            tree.insert({ x,y }, 1);
        else {
            int tmp = tree.query({ 1,y }, { x,n });
            ans.push_back(tmp);
            last_ans = tmp;
        }
    }
    int L = ans.size();
    if (!special) {
        int sum = 0;
        for (int i = 1; i < L; ++i) ans[i] ^= ans[i - 1];
        for (int i = 0; i < L; ++i)
            for (int j = i; j < L; ++j)
                sum = (sum + (ans[j] ^ (i == 0 ? 0 : ans[i - 1]))) % mod;
        cout << sum << endl;
        return 0;
    }
    int K = next_int();
    a = new long long* [L + 1];
    for (int i = 0, j = L; i < L; i++, j--)
        a[i] = new long long[j];
    for (int i = 0; i < L; ++i)
        a[0][i] = ans[i] % mod;
    for (int i = 1; i < L; i++) {
        int k = L - i;
        for (int j = 0; j < k; j++) {
            a[i][j] = (a[i - 1][j] - a[i - 1][j + 1]) % mod;
            if (a[i][j] < 0) a[i][j] += mod;
        }
    }
    long long anss = 0;
    for (int k = 1; k <= K; k++) {
        int l = min(k - 1, L - k);
        int r = max(k - 1, L - k);
        int x = r - l;
        long long val = solve(x, l);
        anss = (anss + val * (x + 1)) % mod;
    }
    anss %= mod;
    if (anss < 0) anss += mod;
    cout << anss << endl;
    return 0;
}
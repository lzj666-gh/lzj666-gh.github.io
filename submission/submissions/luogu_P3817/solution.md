# P3817 题解

好吧这是道水题（只要你找到方法）
首先我们可以把这几个糖果盒分对来讨论；
先从第一个糖果盒和第二个开始；
如果一个糖果盒的数量就超限了，我们当然至少要把它吃到剩下x个；
然后如果单论两个都没有超限，但加起来超限了怎么办呢？
首先第一个糖果盒是只有一个分组的（和第二个），
而第二个糖果盒却有两个分组（和第1个/和第3个）；
所以如果我们吃掉第一个里的，只会减少一个分组的量，而如果吃掉第二个里的，可以减少2个分组的量。所以我们要尽量吃掉第二个里的糖果。
处理好第一个分组后，来看第二个，因为第一个分组已经被处理好了，所以可以无视它，然后问题又变成了前一个问题。
以此类推就好了。

```c
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long sum=0//计数器,n,x;
	cin>>n>>x;//输入
	long long a[n+1];
	cin>>a[1];//处理第一个单独超限。
	if(a[1]>x)
		{
		sum+=a[1]-x;//增加吃的量
		a[1]=x;//a[i]>=x,要吃的最少，即是a[i]=x;
		}
	for(int i=2;i<=n;i++)
		{
		cin>>a[i];//输入
		if(a[i]+a[i-1]>x)//照例处理
			{
			sum+=a[i]+a[i-1]-x;
			a[i]=x-a[i-1];
			}
		}
	cout<<sum;//输出
	return 0;//养成好习惯
} 
```
//  OJ: 洛谷
//  提交ID: 219760330
//  题目ID: T383404
#include<bits/stdc++.h>
#define int long long
using namespace std;
constexpr int N = 4e6 + 10, M = 6e6 + 10;
struct Edge {
	int v, nxt;
} edge[M];
int head[N], idx;
void add(int u, int v) {
	edge[++idx] = { v, head[u] };
	head[u] = idx;
}
void addedge(int u, int v) {
	add(u, v); add(v, u);
}
int T, n, a[100000 + 10];
int mp[10000001], ids[10000001], snt;
bool np[10000001];
int fa[N], sz[N], dfn[N], low[N], idk;
int siz[N], all, ans;
vector<int> prm;
void prep() {
	for (int i = 2; i <= 1e7; ++i) {
		if (!np[i]) mp[i] = i, prm.push_back(i);
		for (const int& j : prm) {
			if (i * j > 1e7) break;
			np[i * j] = 1; mp[i * j] = j;
			if (i % j == 0) break;
		}
	}
	snt = 0;
	for (int i = 2; i <= 1e7; ++i) {
		if (!np[i]) continue;
		int t = i / mp[i];
		if (t > 1 && !np[t]) ids[i] = ++snt;
	}
}
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
void merge(int x, int y) {
	x = find(x), y = find(y);
	if (x == y) return;
	if (sz[x] < sz[y]) swap(x, y);
	sz[x] += sz[y];
	fa[y] = x;
}
void tarjan(int x, int fa) {
	dfn[x] = low[x] = ++idk;
	siz[x] = (x <= n) ? 1 : 0;
	int child = 0;
	int ret = 0, sum = 0;
	for (int i = head[x]; i; i = edge[i].nxt) {
		int v = edge[i].v;
		if (v == fa) continue;
		if (!dfn[v]) {
			child++; tarjan(v, x);
			siz[x] += siz[v]; low[x] = min(low[x], low[v]);
			if (low[v] >= dfn[x]) ret = max(ret, siz[v]), sum += siz[v];
		}
		else low[x] = min(low[x], dfn[v]);
	}
	if (x <= n) {
		int now;
		if (fa == -1)
			if (child >= 2) now = max(ret, all - 1 - sum);
			else now = all - 1;
		else
			if (ret) now = max(ret, all - 1 - sum);
			else now = all - 1;
		ans = min(ans, now);
	}
}
signed main() {
	cin.tie(0)->sync_with_stdio(false);
	prep();
	cin >> T;
	while (T--) {
		memset(head, 0, sizeof(int) * (n + snt + 1));
		memset(dfn, 0, sizeof(int) * (n + snt + 1));
		memset(low, 0, sizeof(int) * (n + snt + 1));
		memset(siz, 0, sizeof(int) * (n + snt + 1));
		cin >> n; idx = 0;
		for (int i = 1; i <= n + snt; ++i) fa[i] = i, sz[i] = (i <= n) ? 1 : 0;
		for (int i = 1; i <= n; ++i) cin >> a[i];
		for (int i = 1; i <= n; ++i) {
			int x = a[i];
			vector<int> d;
			unordered_map<int, int> cnt;
			while (x > 1) {
				int p = mp[x], tot = 0;
				while (x % p == 0) tot++, x /= p;
				d.push_back(p); cnt[p] = tot;
			}
			for (int j = 0; j < d.size(); ++j) {
				int p1 = d[j];
				if (cnt[p1] >= 2) {
					int sm = p1 * p1;
					if (sm <= 1e7 && ids[sm]) {
						addedge(i, n + ids[sm]);
						merge(i, n + ids[sm]);
					}
				}
				for (int k = j + 1; k < d.size(); ++k) {
					int p2 = d[k];
					int sm = p1 * p2;
					if (sm > 1e7) continue;
					if (ids[sm]) {
						addedge(i, n + ids[sm]);
						merge(i, n + ids[sm]);
					}
				}
			}
		}
		int mx = 0, se = 0, mxp = -1;
		for (int i = 1; i <= n + snt; ++i)
			if (fa[i] == i)
				if (sz[i] > mx) se = mx, mx = sz[i], mxp = i;
				else if (sz[i] > se) se = sz[i];
		if (mx == 0) {
			cout << 0 << endl;
			continue;
		}
		idk = 0; ans = mx; all = mx;
		if (mxp != -1) tarjan(mxp, -1);
		cout << max(ans, se) << endl;
	}
	return 0;
}
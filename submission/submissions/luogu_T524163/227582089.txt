//  OJ: 洛谷
//  提交ID: 227582089
//  题目ID: T524163
#include<bits/stdc++.h>
using namespace std;
enum Color {
	Hel, Red, Grn, Org, Blu_0, Blu_1, Yel, Pnk, Vpu
};
enum Element {
	Normal, Fire, Thunder, Ice
};
int8_t col[1000 + 5][1000 + 5];
int16_t n, m, t[100], d, sx, sy, tx, ty;
int64_t dis[1000 + 5][1000 + 5][4];
int16_t dthun[1000 + 5][1000 + 5];
void dfs_thunder(int x, int y, int k) {
	if (!(1 <= x && x <= n && 1 <= y && y <= n)) return;
	if (dthun[x][y] >= k) return;
	if (col[x][y] != Blu_0) return;
	dthun[x][y] = k; col[x][y] = Blu_1;
	dfs_thunder(x - 1, y, k - 1);
	dfs_thunder(x + 1, y, k - 1);
	dfs_thunder(x, y - 1, k - 1);
	dfs_thunder(x, y + 1, k - 1);
}
char opt[1000 + 5];
int8_t change(char opt) {
	switch (opt) {
	case 'R':return Red;
	case 'G':return Grn;
	case 'O':return Org;
	case 'B':return Blu_0;
	case 'Y':return Yel;
	case 'H':return Hel;
	case 'P':return Pnk;
	case 'V':return Vpu;
	}
}
struct Node {
	int16_t x, y; int8_t Ele;
	int64_t dis;
	friend bool operator<(const Node& a, const Node& b) {
		return a.dis > b.dis;
	}
};
priority_queue<Node>q;
bool update(Node& now, int dx, int dy) {
	int8_t c = col[now.x][now.y];
	if (c == Red) {
		now.dis = -1;
		return 0;
	}
	if (c == Grn) {
		now.dis += t[1];
		return 1;
	}
	if (c == Org) {
		now.Ele = Fire;
		now.dis += t[2];
		return 1;
	}
	if (c == Blu_1) {
		now.dis = -1;
		return 0;
	}
	if (c == Blu_0) {
		if (now.Ele == Fire) {
			now.dis = -1;
			return 0;
		}
		now.dis += t[3];
	}
	if (c == Yel) {
		now.dis = -1;
		return 0;
	}
	if (c == Hel) {
		now.dis = -1;
		return 0;
	}
	if (c == Pnk) {
		now.dis += t[5];
		return 1;
	}
	if (c == Vpu) {
		now.dis += t[4];
		if (col[now.x + dx][now.y + dy] == Hel) return 1;
		now.x += dx; now.y += dy;
		return update(now, dx, dy);
	}
    exit(c);
    return 0;
}
int32_t main(int32_t argc, char** argv) {
//	if (argc >= 2) freopen(argv[1], "r", stdin);
//	else freopen("element.in", "r", stdin);
//	if (argc >= 3) freopen(argv[2], "w", stdout);
//	else freopen("element.out", "w", stdout);
	cin.tie(0)->sync_with_stdio(false);
	cin >> n >> m >> sx >> sy >> tx >> ty;
	cin >> t[1] >> t[2] >> t[3] >> t[4] >> t[5] >> d;
	for (int i = 1; i <= n; ++i) {
		cin >> opt;
		for (int j = 1; j <= n; ++j)
			col[i][j] = change(opt[j - 1]);
	}
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j)
			if (col[i][j] == Yel)
				dfs_thunder(i + 1, j, d),
				dfs_thunder(i - 1, j, d),
				dfs_thunder(i, j + 1, d),
				dfs_thunder(i, j - 1, d);
	memset(dis, 0x3f, sizeof dis);
	Node start;
	start.dis = 0;
	start.Ele = Normal;
	start.x = sx;
	start.y = sy;
	q.push(start);
	while (!q.empty()) {
		Node now = q.top(); q.pop();
		if (dis[now.x][now.y][now.Ele] <= now.dis) continue;
		dis[now.x][now.y][now.Ele] = now.dis;
		Node upd = now; upd.x++;
		if ((col[now.x][now.y] != Vpu || col[now.x - 1][now.y] == Hel) && update(upd, 1, 0)) q.push(upd);
		upd = now; upd.x--;
		if ((col[now.x][now.y] != Vpu || col[now.x + 1][now.y] == Hel) && update(upd, -1, 0)) q.push(upd);
		upd = now; upd.y++;
		if ((col[now.x][now.y] != Vpu || col[now.x][now.y - 1] == Hel) && update(upd, 0, 1)) q.push(upd);
		upd = now; upd.y--;
		if ((col[now.x][now.y] != Vpu || col[now.x][now.y + 1] == Hel) && update(upd, 0, -1)) q.push(upd);
	}
	int64_t ans = LLONG_MAX;
	for (int i = 0; i < 4; ++i) ans = min(ans, dis[tx][ty][i]);
	if (ans == dis[0][0][0]) ans = -1;
	cout << ans << endl;
	return 0;
}
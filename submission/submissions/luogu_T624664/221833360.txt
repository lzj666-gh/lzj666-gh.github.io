//  OJ: 洛谷
//  提交ID: 221833360
//  题目ID: T624664
#include<bits/stdc++.h>
using namespace std;
template<int mod>
struct mod_int {
	long long val;
	static long long pow(long long base, long long exp) { long long res = 1; while (exp) { if (exp & 1) res = res * base % mod; base = base * base % mod; exp >>= 1; } return res; }
	mod_int inv() const { return mod_int(pow(val, mod - 2)); }
	mod_int() :val(0) {}
	template<typename T> mod_int(T v = 0) : val(v % mod) { if (val < 0) val += mod; }
	mod_int operator+(const mod_int& other) const { return mod_int(val + other.val); }
	mod_int operator-(const mod_int& other) const { return mod_int(val - other.val); }
	mod_int operator*(const mod_int& other) const { return mod_int(val * other.val); }
	mod_int operator/(const mod_int& other) const { return mod_int(val * other.inv().val); }
	mod_int& operator+=(const mod_int& other) { val = (val + other.val) % mod; return *this; }
	mod_int& operator-=(const mod_int& other) { val = (val - other.val + mod) % mod; return *this; }
	mod_int& operator*=(const mod_int& other) { val = (val * other.val) % mod; return *this; }
	mod_int& operator/=(const mod_int& other) { val = (val * other.inv().val) % mod; return *this; }
	mod_int operator-() const { return mod_int(-val); }
	mod_int operator++() { return *this += 1; }
	mod_int operator--() { return *this -= 1; }
	mod_int operator++(int) { mod_int temp = *this; *this += 1; return temp; }
	mod_int operator--(int) { mod_int temp = *this; *this -= 1; return temp; }
	bool operator==(const mod_int& other) const { return val == other.val; }
	bool operator!=(const mod_int& other) const { return val != other.val; }
	bool operator<(const mod_int& other) const { return val < other.val; }
	bool operator>(const mod_int& other) const { return val > other.val; }
	bool operator<=(const mod_int& other) const { return val <= other.val; }
	bool operator>=(const mod_int& other) const { return val >= other.val; }
	mod_int& operator<<(const mod_int& other) { val = (val << other.val) % mod; return *this; }
	mod_int& operator>>(const mod_int& other) { val = (val >> other.val) % mod; return *this; }
	mod_int& operator|(const mod_int& other) { val = (val | other.val) % mod; return *this; }
	mod_int& operator&(const mod_int& other) { val = (val & other.val) % mod; return *this; }
	mod_int& operator^(const mod_int& other) { val = (val ^ other.val) % mod; return *this; }
};
constexpr int N = 1e7 + 5;
using iint = mod_int<int(1e8 + 7)>;
vector<int>prm;
bool vis[N];
iint h[N];
void prep() {
	h[1] = 1;
	for (int i = 2; i < N; ++i) {
		if (!vis[i]) {
			prm.push_back(i);
			h[i] = -iint(i * i) + i;
		}
		for (int& p : prm) {
			if (p * i >= N) break;
			vis[p * i] = 1;
			if (i % p == 0) {
				h[i * p] = h[i] * p;
				break;
			}
			h[i * p] = h[p] * h[i];
		}
	}
	for (int i = 1; i < N; ++i) h[i] += h[i - 1];
}
iint C2(iint a) {
	return a * (a + 1) / 2;
}
iint sol(int n, int m) {
	iint ans = 0;
	if (n > m) swap(n, m);
	for (int l = 1, r; l <= n; l = r + 1) {
		r = min(n / (n / l), m / (m / l));
		ans += C2(n / l) * C2(m / l) * (h[r] - h[l - 1]);
	}
	return ans;
}
signed main() {
	prep();
	cin.tie(0)->sync_with_stdio(false);
	int T, n, m;
	cin >> T;
	while (T--) {
		cin >> n >> m;
		cout << sol(n, m).val << endl;
	}
	return 0;
}
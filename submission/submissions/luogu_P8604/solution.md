# P8604 题解

 _蒟蒻的第一篇题解_ 

[题目传送门](https://www.luogu.com.cn/problem/P8604)

---

**题意简析**
1. 共有 $n$ 个点，$m$ 个通道（无向）。
2. 给出起点 $u$ ，终点 $v$。求这两点之间，有多少个点删去后就能使这两点不连通。
3. 如果 $u$ 和 $v$ 之间没有路径连通，输出'$-1$'。

------------

### 算法思路

>可以使用 dfs（深度优先搜索）求解，求出 $u$ 到 $v$ 间的每一条路径，将路径总数统计，并将被经过的点被经过总数加一。如果一个点被经过的次数与总路径条数相等，那么这一个点就是 $u$ 和 $v$ 的关键点。

举个栗子：
点 $1,2,3,4,5$ 中， $1$ 到 $5$ 有两条路径：

```latex
1 -> 2 -> 3 -> 4 -> 5

1 -> 2 -> 4 -> 5
```

**其中除去 $1$ , $5$ 有 $2$ 和 $4$ 两个点被经过两次，所以 $2$ 和 $4$为关于 $1$ 和 $5$ 的关键点，危险系数为 $2$。**


- 另外，最后统计被经过的次数与总路径条数相等的点得个数时，起点 $u$ 和终点 $v$ 不计算在内。


### 代码注释：

> $n$, $m$, $u$, $v$ 如题面， $ans$ 存危险系数， $cnt$ 为dfs时记录这个点被走过的总次数， $sum$ 为路径总数 。
>
> $a$ 为邻接矩阵，存连通情况， $1$ 为连通，也可以使用 vector 邻接表来存储 ； $bj$( $biaoji$) 为 dfs 时记录这个点是否被走过的 。

## 代码： 
```cpp
#include<bits/stdc++.h>
#define LL long long
#define made return
#define in 0
#define China ;
using namespace std;
LL n,m,u,v,ans,cnt[1010],sum;
bool bj[1010],a[1010][1010];
void dfs(LL now){
	if(now==v){//如果走到终点了， 
		sum++;//路径总数加一。 
		for(int i=1;i<=n;i++)
			if(bj[i]==1)cnt[i]++;//每个被走过的点，被走总次数加一 
	}
	else{
		for(int i=1;i<=n;i++)
			if(a[now][i]==1&&bj[i]==0){//如果两点连通且下一步要走到的点未被走过， 
				bj[i]=1;//标记。
				dfs(i);
				bj[i]=0;//回溯一步。 
			}
	}
}
int main(){
	scanf("%lld%lld",&n,&m);
	while(m--){
		scanf("%lld%lld",&u,&v);
		a[u][v]=a[v][u]=1;//输入邻接矩阵。因为是无向的，所以u到v和v到u都要设为1。 
	}
	scanf("%lld%lld",&u,&v);
	dfs(u);
	if(sum>0){//dfs求解
		for(int i=1;i<=n;i++)
			if(cnt[i]==sum)ans++;//如果这个点被走过的总次数与路径总数相等，那么删去这个点起点与终点间一定不连通。 
		printf("%lld",ans-1);//因为起点也被算在内，所以总危险系数要减去起点的1。 
	}
	else printf("-1");//如果询问的两点无路径连通则输出'-1'。
	made in China 
}
//made in China. 中国制造。
```
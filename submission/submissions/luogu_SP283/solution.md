# SP283 题解

翻译题解~~素质二连~~

 这道题~~很明显~~是一道线性DP

 但是第N小时与下一天第一小时连着的条件真的很不爽！

 如果没有这个条件这道题简直秒解！（状态转移方程就不赘述，下面代码里有）

------------
 当你有以上的想法的时候就表示你离标算又近了一步【滑稽

 不妨先把“第N小时与下一天第一小时连着”的条件去掉，变成一个普通的线性DP。

 而上面的普通线性DP与本题的环形DP本质区别在哪里？
------------
 考虑一下去掉条件的DP，会发现第一天第N小时如果在休息，是无法影响到第二天的第一个小时的，也就是没有计算到第一天第N个小时休息延续到第二天第一个小时的情况

 那我们只需要强行令第N个小时休息并延续到第1个小时使第一个小时获得休息能量并再做一次DP就可以了

 这一次DP里状态转移方程同上，只不过第一个小时算上休息恢复的能量，而结果则只能取第N个小时在休息时的最大能量。

 两个DP综合起来取max就是答案。

 老规矩

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int max(int a , int b){
    return a > b ? a : b;
}
int DP1[3831][3831][2] , DP2[3831][3831][2] , num[3831];
//DP1断环，DP2强制接环
int main(){
    int T , N , K;
 	for(scanf("%d" , &T) ; T ; T--){
 		scanf("%d%d" , &N , &K);
 		for(int i = 1 ; i <= N ; i++)	scanf("%d" , num + i);
 		for(int i = 0 ; i <= N ; i++)
 			for(int j = 0 ; j <= K ; j++)
 				DP1[i][j][0] = DP1[i][j][1] = DP2[i][j][0] = DP2[i][j][1] = -0x3f3f3f3f;
 		DP1[1][1][1] = DP1[1][0][0] = 0;
 		DP2[1][1][1] = num[1];
        for(int i = 2 ; i <= N ; i++)
 			for(int j = 0 ; j <= N && j <= K ; j++){
 				DP1[i][j][0] = max(DP1[i - 1][j][0] , DP1[i - 1][j][1]);
 				DP2[i][j][0] = max(DP2[i - 1][j][0] , DP2[i - 1][j][1]);
                if(j){
                    DP1[i][j][1] = max(DP1[i - 1][j - 1][1] + num[i] , DP1[i - 1][j - 1][0]);
                    DP2[i][j][1] = max(DP2[i - 1][j - 1][1] + num[i] , DP2[i - 1][j - 1][0]);
                }
            }
            //状态转移
        cout << max(max(DP1[N][K][0] , DP1[N][K][1]) , DP2[N][K][1]) << endl;
        //注意DP2（强制接环）中只有第N个小时在休息时的答案才能够计算入内。
    }
    return 0;
}
```
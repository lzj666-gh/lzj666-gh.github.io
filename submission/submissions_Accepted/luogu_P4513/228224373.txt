//  OJ: 洛谷
//  提交ID: 228224373
//  题目ID: P4513
#include<bits/stdc++.h>
#define int long long
namespace IO {
	const int SIZE = (1 << 21) + 1;
	char ibuf[SIZE], * iS, * iT, obuf[SIZE], * oS = obuf, * oT = obuf + SIZE - 1; char _st[55]; int _qr = 0;
	inline char gc() { return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++); }
	inline void qread() {}
	inline void qread(char& IEE) { IEE = gc(); }
	template<class T1, class ...T2> inline void qread(T1& IEE, T2&... ls) { T1 __ = 0, ___ = 1; char ch; while (!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___; do { __ = (__ << 1) + (__ << 3) + (ch ^ 48); } while (isdigit(ch = gc())); __ *= ___; IEE = __; qread(ls...); }
	template<class... T2> inline void qread(char& IEE, T2&... ls) { IEE = gc(); qread(ls...); }
	inline void flush() { fwrite(obuf, 1, oS - obuf, stdout); oS = obuf; }
	inline void putc_(char _x) { *oS++ = _x; if (oS == oT) flush(); }
	inline void qwrite() {}
	inline void qwrite(char IEE) { putc_(IEE); }
	inline void qwrite(const char* str) { while (*str != '\0') putc_(*str++); }
	inline void qwrite(const std::string& IEE) { qwrite(IEE.c_str()); }
	template<class... T2> inline void qwrite(const char IEE, T2... ls) { putc_(IEE); qwrite(ls...); }
	template<class... T2> inline void qwrite(const char* str, T2... ls) { while (*str != '\0') putc_(*str++); qwrite(ls...); }
	template<class... T2> inline void qwrite(const std::string& IEE, T2... ls) { qwrite(IEE.c_str(), ls...); }
	template<class T1, class ...T2> inline void qwrite(T1 IEE, T2... ls) { if (!IEE) putc_('0'); if (IEE < 0) putc_('-'), IEE = -IEE; while (IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10; while (_qr) putc_(_st[_qr--]); qwrite(ls...); }
	struct Flusher_ { ~Flusher_() { flush(); } }io_flusher;
}
using namespace IO;
using namespace std;
int n, m, a[500000 + 5];
#define lc(p) (p << 1)
#define rc(p) (p << 1 | 1)
#define mid (l + r >> 1)
#define lson lc(p), l, mid
#define rson rc(p), mid + 1, r
struct Node {
	int ansl, ansr, ans, sum;
	Node() :ansl(INT_MIN), ansr(INT_MIN), ans(INT_MIN), sum(0) {}
}tree[500000 << 2 | 3];
Node operator+(const Node& a, const Node& b) {
	Node res;
	res.sum = a.sum + b.sum;
	res.ansl = max(a.ansl, a.sum + b.ansl);
	res.ansr = max(b.ansr, b.sum + a.ansr);
	res.ans = max(a.ans, b.ans);
	res.ans = max(res.ans, a.ansr + b.ansl);
	res.ans = max(res.ans, res.ansl);
	res.ans = max(res.ans, res.ansr);
	return res;
}
void pushup(int p) {
	tree[p] = tree[lc(p)] + tree[rc(p)];
}
void build(int p, int l, int r) {
	if (l == r) {
		tree[p].ansl = tree[p].ansr = tree[p].ans = tree[p].sum = a[l];
		return;
	}
	build(lson);
	build(rson);
	pushup(p);
}
void change(int p, int l, int r, int x, int k) {
	if (!(l <= x && x <= r)) return;
	if (l == r) {
		tree[p].ansl = tree[p].ansr = tree[p].ans = tree[p].sum = k;
		return;
	}
	change(lson, x, k);
	change(rson, x, k);
	pushup(p);
}
Node query(int p, int l, int r, int x, int y) {
	if (y < l || r < x) return Node();
	if (x <= l && r <= y) return tree[p];
	return query(lson, x, y) + query(rson, x, y);
}
signed main() {
	cin.tie(0)->sync_with_stdio(false);
	qread(n, m);
	for (int i = 1; i <= n; ++i) qread(a[i]);
	build(1, 1, n);
	while (m--) {
		int opt, x, y;
		qread(opt, x, y);
		if (opt == 1) {
			if (x > y) swap(x, y);
			qwrite(query(1, 1, n, x, y).ans, '\n');
		}
		else change(1, 1, n, x, y);
	}
	return 0;
}